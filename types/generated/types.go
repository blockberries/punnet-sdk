// Code generated by cramberry. DO NOT EDIT.
// Source: /Users/clockwork/.agent-workspaces/theorist/issue-4/schema/types.cram

package types

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/blockberries/cramberry/pkg/cramberry"
)




type Account struct {
Name string `cramberry:"1" json:"name"`
Authority Authority `cramberry:"2" json:"authority"`
Nonce uint64 `cramberry:"3" json:"nonce"`
CreatedAt int64 `cramberry:"4" json:"created_at"`
UpdatedAt int64 `cramberry:"5" json:"updated_at"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Account) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Account) EncodeTo(w *cramberry.Writer) {
	if m.Name != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Name)
	}
	w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
	m.Authority.EncodeTo(w)
	if m.Nonce != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.Nonce)
	}
	if m.CreatedAt != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.CreatedAt)
	}
	if m.UpdatedAt != 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.UpdatedAt)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Account) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Account) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Name = r.ReadString()
		case 2:
			m.Authority.DecodeFrom(r)
		case 3:
			m.Nonce = r.ReadUint64()
		case 4:
			m.CreatedAt = r.ReadInt64()
		case 5:
			m.UpdatedAt = r.ReadInt64()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *Account) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"name":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Name))

	buf.WriteString(",")
	buf.WriteString(`"authority":`)
	if msgJSON, err := m.Authority.ToJSON(); err != nil {
		return "", err
	} else {
		buf.WriteString(msgJSON)
	}

	buf.WriteString(",")
	buf.WriteString(`"nonce":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatUint64ToString(uint64(m.Nonce)))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"created_at":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatInt64ToString(int64(m.CreatedAt)))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"updated_at":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatInt64ToString(int64(m.UpdatedAt)))
	buf.WriteString(`"`)

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *Account) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"name": true,
		"authority": true,
		"nonce": true,
		"created_at": true,
		"updated_at": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["name"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Name", err)
		}
		m.Name = strVal
	}

	if rawValue, ok := raw["authority"]; ok {
		var msg Authority
		if err := msg.FromJSON(string(rawValue)); err != nil {
			return fmt.Errorf("field %s: %w", "m.Authority", err)
		}
		m.Authority = msg
	}

	if rawValue, ok := raw["nonce"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseUint64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Nonce", err)
			} else {
				m.Nonce = uint64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Nonce = uint64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Nonce")
		}
	}

	if rawValue, ok := raw["created_at"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseInt64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.CreatedAt", err)
			} else {
				m.CreatedAt = int64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.CreatedAt = int64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.CreatedAt")
		}
	}

	if rawValue, ok := raw["updated_at"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseInt64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.UpdatedAt", err)
			} else {
				m.UpdatedAt = int64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.UpdatedAt = int64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.UpdatedAt")
		}
	}


	return nil
}

type Authority struct {
Threshold uint64 `cramberry:"1" json:"threshold"`
KeyWeights map[string]uint64 `cramberry:"2" json:"key_weights"`
AccountWeights map[string]uint64 `cramberry:"3" json:"account_weights"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Authority) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Authority) EncodeTo(w *cramberry.Writer) {
	if m.Threshold != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.Threshold)
	}
	if m.KeyWeights != nil {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.KeyWeights)))
		for k, v := range m.KeyWeights {
			w.WriteString(k)
			w.WriteUint64(v)
		}
	}
	if m.AccountWeights != nil {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.AccountWeights)))
		for k, v := range m.AccountWeights {
			w.WriteString(k)
			w.WriteUint64(v)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Authority) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Authority) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Threshold = r.ReadUint64()
		case 2:
			n := r.ReadMapHeader()
		if r.Err() != nil {
			return
		}
		m.KeyWeights = make(map[string]uint64, n)
		for i := 0; i < n; i++ {
			var k string
			k = r.ReadString()
			var v uint64
			v = r.ReadUint64()
			m.KeyWeights[k] = v
		}
		case 3:
			n := r.ReadMapHeader()
		if r.Err() != nil {
			return
		}
		m.AccountWeights = make(map[string]uint64, n)
		for i := 0; i < n; i++ {
			var k string
			k = r.ReadString()
			var v uint64
			v = r.ReadUint64()
			m.AccountWeights[k] = v
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *Authority) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"threshold":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatUint64ToString(uint64(m.Threshold)))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"key_weights":`)
	{
		buf.WriteString("{")
		keys := make([]string, 0, len(m.KeyWeights))
		for k := range m.KeyWeights {
			keys = append(keys, k)
		}
		keys = cramberry.SortMapKeysLexicographic(keys)
		for i, keyStr := range keys {
			if i > 0 {
				buf.WriteString(",")
			}
			buf.WriteString(cramberry.EscapeJSONString(keyStr))
			buf.WriteString(":")
			k := keyStr
			v := m.KeyWeights[k]
			buf.WriteString(`"`)
			buf.WriteString(cramberry.FormatUint64ToString(uint64(v)))
			buf.WriteString(`"`)
		}
		buf.WriteString("}")
	}

	buf.WriteString(",")
	buf.WriteString(`"account_weights":`)
	{
		buf.WriteString("{")
		keys := make([]string, 0, len(m.AccountWeights))
		for k := range m.AccountWeights {
			keys = append(keys, k)
		}
		keys = cramberry.SortMapKeysLexicographic(keys)
		for i, keyStr := range keys {
			if i > 0 {
				buf.WriteString(",")
			}
			buf.WriteString(cramberry.EscapeJSONString(keyStr))
			buf.WriteString(":")
			k := keyStr
			v := m.AccountWeights[k]
			buf.WriteString(`"`)
			buf.WriteString(cramberry.FormatUint64ToString(uint64(v)))
			buf.WriteString(`"`)
		}
		buf.WriteString("}")
	}

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *Authority) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"threshold": true,
		"key_weights": true,
		"account_weights": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["threshold"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseUint64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Threshold", err)
			} else {
				m.Threshold = uint64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Threshold = uint64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Threshold")
		}
	}

	if rawValue, ok := raw["key_weights"]; ok {
		var mapRaw map[string]json.RawMessage
		if err := json.Unmarshal(rawValue, &mapRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.KeyWeights", err)
		}
		m.KeyWeights = make(map[string]uint64, len(mapRaw))
		for keyStr, valRaw := range mapRaw {
			k := keyStr
			rawValue = valRaw
				var strVal string
				var numVal float64
				if err := json.Unmarshal(rawValue, &strVal); err == nil {
						if v, err := cramberry.ParseUint64FromString(strVal); err != nil {
								return fmt.Errorf("field %s: %w", "m.KeyWeights[k]", err)
						} else {
								m.KeyWeights[k] = uint64(v)
						}
				} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
						m.KeyWeights[k] = uint64(numVal)
				} else {
						return fmt.Errorf("field %s: expected string or number", "m.KeyWeights[k]")
				}
		}
	}

	if rawValue, ok := raw["account_weights"]; ok {
		var mapRaw map[string]json.RawMessage
		if err := json.Unmarshal(rawValue, &mapRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.AccountWeights", err)
		}
		m.AccountWeights = make(map[string]uint64, len(mapRaw))
		for keyStr, valRaw := range mapRaw {
			k := keyStr
			rawValue = valRaw
				var strVal string
				var numVal float64
				if err := json.Unmarshal(rawValue, &strVal); err == nil {
						if v, err := cramberry.ParseUint64FromString(strVal); err != nil {
								return fmt.Errorf("field %s: %w", "m.AccountWeights[k]", err)
						} else {
								m.AccountWeights[k] = uint64(v)
						}
				} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
						m.AccountWeights[k] = uint64(numVal)
				} else {
						return fmt.Errorf("field %s: expected string or number", "m.AccountWeights[k]")
				}
		}
	}


	return nil
}

type Authorization struct {
Signatures []Signature `cramberry:"1" json:"signatures"`
AccountAuthorizations map[string]Authorization `cramberry:"2" json:"account_authorizations"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Authorization) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Authorization) EncodeTo(w *cramberry.Writer) {
	if len(m.Signatures) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Signatures)))
		for _, v := range m.Signatures {
			v.EncodeTo(w)
		}
	}
	if m.AccountAuthorizations != nil {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.AccountAuthorizations)))
		for k, v := range m.AccountAuthorizations {
			w.WriteString(k)
			v.EncodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Authorization) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Authorization) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := r.ReadArrayHeader()
		if r.Err() != nil {
			return
		}
		m.Signatures = make([]Signature, n)
		for i := 0; i < n; i++ {
			m.Signatures[i].DecodeFrom(r)
		}
		case 2:
			n := r.ReadMapHeader()
		if r.Err() != nil {
			return
		}
		m.AccountAuthorizations = make(map[string]Authorization, n)
		for i := 0; i < n; i++ {
			var k string
			k = r.ReadString()
			var v Authorization
			v.DecodeFrom(r)
			m.AccountAuthorizations[k] = v
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *Authorization) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"signatures":`)
	buf.WriteString("[")
	for i, v := range m.Signatures {
		if i > 0 {
			buf.WriteString(",")
		}
		if msgJSON, err := v.ToJSON(); err != nil {
				return "", err
		} else {
				buf.WriteString(msgJSON)
		}
	}
	buf.WriteString("]")

	buf.WriteString(",")
	buf.WriteString(`"account_authorizations":`)
	{
		buf.WriteString("{")
		keys := make([]string, 0, len(m.AccountAuthorizations))
		for k := range m.AccountAuthorizations {
			keys = append(keys, k)
		}
		keys = cramberry.SortMapKeysLexicographic(keys)
		for i, keyStr := range keys {
			if i > 0 {
				buf.WriteString(",")
			}
			buf.WriteString(cramberry.EscapeJSONString(keyStr))
			buf.WriteString(":")
			k := keyStr
			v := m.AccountAuthorizations[k]
			if msgJSON, err := v.ToJSON(); err != nil {
						return "", err
			} else {
						buf.WriteString(msgJSON)
			}
		}
		buf.WriteString("}")
	}

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *Authorization) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"signatures": true,
		"account_authorizations": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["signatures"]; ok {
		var arrRaw []json.RawMessage
		if err := json.Unmarshal(rawValue, &arrRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.Signatures", err)
		}
		m.Signatures = make([]Signature, len(arrRaw))
		for i, elemRaw := range arrRaw {
			rawValue = elemRaw
				var msg Signature
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.Signatures[i]", err)
				}
				m.Signatures[i] = msg
		}
	}

	if rawValue, ok := raw["account_authorizations"]; ok {
		var mapRaw map[string]json.RawMessage
		if err := json.Unmarshal(rawValue, &mapRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.AccountAuthorizations", err)
		}
		m.AccountAuthorizations = make(map[string]Authorization, len(mapRaw))
		for keyStr, valRaw := range mapRaw {
			k := keyStr
			rawValue = valRaw
				var msg Authorization
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.AccountAuthorizations[k]", err)
				}
				m.AccountAuthorizations[k] = msg
		}
	}


	return nil
}

type Signature struct {
PubKey []byte `cramberry:"1" json:"pub_key"`
Sig []byte `cramberry:"2" json:"sig"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Signature) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Signature) EncodeTo(w *cramberry.Writer) {
	if len(m.PubKey) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.PubKey)
	}
	if len(m.Sig) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Sig)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Signature) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Signature) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.PubKey = r.ReadBytes()
		case 2:
			m.Sig = r.ReadBytes()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *Signature) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"pub_key":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.PubKey))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"sig":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.Sig))
	buf.WriteString(`"`)

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *Signature) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"pub_key": true,
		"sig": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["pub_key"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.PubKey", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.PubKey", err)
		} else {
			m.PubKey = decoded
		}
	}

	if rawValue, ok := raw["sig"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Sig", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.Sig", err)
		} else {
			m.Sig = decoded
		}
	}


	return nil
}

type Coin struct {
Denom string `cramberry:"1" json:"denom"`
Amount uint64 `cramberry:"2" json:"amount"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Coin) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Coin) EncodeTo(w *cramberry.Writer) {
	if m.Denom != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Denom)
	}
	if m.Amount != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.Amount)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Coin) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Coin) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Denom = r.ReadString()
		case 2:
			m.Amount = r.ReadUint64()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *Coin) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"denom":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Denom))

	buf.WriteString(",")
	buf.WriteString(`"amount":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatUint64ToString(uint64(m.Amount)))
	buf.WriteString(`"`)

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *Coin) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"denom": true,
		"amount": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["denom"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Denom", err)
		}
		m.Denom = strVal
	}

	if rawValue, ok := raw["amount"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseUint64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Amount", err)
			} else {
				m.Amount = uint64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Amount = uint64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Amount")
		}
	}


	return nil
}

type Coins struct {
Coins []Coin `cramberry:"1" json:"coins"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Coins) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Coins) EncodeTo(w *cramberry.Writer) {
	if len(m.Coins) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Coins)))
		for _, v := range m.Coins {
			v.EncodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Coins) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Coins) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := r.ReadArrayHeader()
		if r.Err() != nil {
			return
		}
		m.Coins = make([]Coin, n)
		for i := 0; i < n; i++ {
			m.Coins[i].DecodeFrom(r)
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *Coins) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"coins":`)
	buf.WriteString("[")
	for i, v := range m.Coins {
		if i > 0 {
			buf.WriteString(",")
		}
		if msgJSON, err := v.ToJSON(); err != nil {
				return "", err
		} else {
				buf.WriteString(msgJSON)
		}
	}
	buf.WriteString("]")

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *Coins) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"coins": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["coins"]; ok {
		var arrRaw []json.RawMessage
		if err := json.Unmarshal(rawValue, &arrRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.Coins", err)
		}
		m.Coins = make([]Coin, len(arrRaw))
		for i, elemRaw := range arrRaw {
			rawValue = elemRaw
				var msg Coin
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.Coins[i]", err)
				}
				m.Coins[i] = msg
		}
	}


	return nil
}

type Transaction struct {
Account string `cramberry:"1" json:"account"`
Messages []Any `cramberry:"2" json:"messages"`
Authorization Authorization `cramberry:"3" json:"authorization"`
Nonce uint64 `cramberry:"4" json:"nonce"`
Memo string `cramberry:"5" json:"memo"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Transaction) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Transaction) EncodeTo(w *cramberry.Writer) {
	if m.Account != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Account)
	}
	if len(m.Messages) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Messages)))
		for _, v := range m.Messages {
			v.EncodeTo(w)
		}
	}
	w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
	m.Authorization.EncodeTo(w)
	if m.Nonce != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.Nonce)
	}
	if m.Memo != "" {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Memo)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Transaction) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Transaction) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Account = r.ReadString()
		case 2:
			n := r.ReadArrayHeader()
		if r.Err() != nil {
			return
		}
		m.Messages = make([]Any, n)
		for i := 0; i < n; i++ {
			m.Messages[i].DecodeFrom(r)
		}
		case 3:
			m.Authorization.DecodeFrom(r)
		case 4:
			m.Nonce = r.ReadUint64()
		case 5:
			m.Memo = r.ReadString()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *Transaction) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"account":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Account))

	buf.WriteString(",")
	buf.WriteString(`"messages":`)
	buf.WriteString("[")
	for i, v := range m.Messages {
		if i > 0 {
			buf.WriteString(",")
		}
		if msgJSON, err := v.ToJSON(); err != nil {
				return "", err
		} else {
				buf.WriteString(msgJSON)
		}
	}
	buf.WriteString("]")

	buf.WriteString(",")
	buf.WriteString(`"authorization":`)
	if msgJSON, err := m.Authorization.ToJSON(); err != nil {
		return "", err
	} else {
		buf.WriteString(msgJSON)
	}

	buf.WriteString(",")
	buf.WriteString(`"nonce":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatUint64ToString(uint64(m.Nonce)))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"memo":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Memo))

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *Transaction) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"account": true,
		"messages": true,
		"authorization": true,
		"nonce": true,
		"memo": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["account"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Account", err)
		}
		m.Account = strVal
	}

	if rawValue, ok := raw["messages"]; ok {
		var arrRaw []json.RawMessage
		if err := json.Unmarshal(rawValue, &arrRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.Messages", err)
		}
		m.Messages = make([]Any, len(arrRaw))
		for i, elemRaw := range arrRaw {
			rawValue = elemRaw
				var msg Any
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.Messages[i]", err)
				}
				m.Messages[i] = msg
		}
	}

	if rawValue, ok := raw["authorization"]; ok {
		var msg Authorization
		if err := msg.FromJSON(string(rawValue)); err != nil {
			return fmt.Errorf("field %s: %w", "m.Authorization", err)
		}
		m.Authorization = msg
	}

	if rawValue, ok := raw["nonce"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseUint64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Nonce", err)
			} else {
				m.Nonce = uint64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Nonce = uint64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Nonce")
		}
	}

	if rawValue, ok := raw["memo"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Memo", err)
		}
		m.Memo = strVal
	}


	return nil
}

type Any struct {
TypeUrl string `cramberry:"1" json:"type_url"`
Value []byte `cramberry:"2" json:"value"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Any) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Any) EncodeTo(w *cramberry.Writer) {
	if m.TypeUrl != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.TypeUrl)
	}
	if len(m.Value) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Value)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Any) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Any) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.TypeUrl = r.ReadString()
		case 2:
			m.Value = r.ReadBytes()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *Any) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"type_url":`)
	buf.WriteString(cramberry.EscapeJSONString(m.TypeUrl))

	buf.WriteString(",")
	buf.WriteString(`"value":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.Value))
	buf.WriteString(`"`)

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *Any) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"type_url": true,
		"value": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["type_url"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.TypeUrl", err)
		}
		m.TypeUrl = strVal
	}

	if rawValue, ok := raw["value"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Value", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.Value", err)
		} else {
			m.Value = decoded
		}
	}


	return nil
}

type ValidatorUpdate struct {
PubKey []byte `cramberry:"1" json:"pub_key"`
Power int64 `cramberry:"2" json:"power"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ValidatorUpdate) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *ValidatorUpdate) EncodeTo(w *cramberry.Writer) {
	if len(m.PubKey) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.PubKey)
	}
	if m.Power != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Power)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ValidatorUpdate) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *ValidatorUpdate) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.PubKey = r.ReadBytes()
		case 2:
			m.Power = r.ReadInt64()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *ValidatorUpdate) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"pub_key":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.PubKey))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"power":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatInt64ToString(int64(m.Power)))
	buf.WriteString(`"`)

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *ValidatorUpdate) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"pub_key": true,
		"power": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["pub_key"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.PubKey", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.PubKey", err)
		} else {
			m.PubKey = decoded
		}
	}

	if rawValue, ok := raw["power"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseInt64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Power", err)
			} else {
				m.Power = int64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Power = int64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Power")
		}
	}


	return nil
}

type BlockHeader struct {
Height int64 `cramberry:"1" json:"height"`
Time int64 `cramberry:"2" json:"time"`
AppHash []byte `cramberry:"3" json:"app_hash"`
ProposerAddress []byte `cramberry:"4" json:"proposer_address"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlockHeader) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *BlockHeader) EncodeTo(w *cramberry.Writer) {
	if m.Height != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	if m.Time != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Time)
	}
	if len(m.AppHash) > 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.AppHash)
	}
	if len(m.ProposerAddress) > 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.ProposerAddress)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlockHeader) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *BlockHeader) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Height = r.ReadInt64()
		case 2:
			m.Time = r.ReadInt64()
		case 3:
			m.AppHash = r.ReadBytes()
		case 4:
			m.ProposerAddress = r.ReadBytes()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *BlockHeader) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"height":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatInt64ToString(int64(m.Height)))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"time":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatInt64ToString(int64(m.Time)))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"app_hash":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.AppHash))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"proposer_address":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.ProposerAddress))
	buf.WriteString(`"`)

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *BlockHeader) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"height": true,
		"time": true,
		"app_hash": true,
		"proposer_address": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["height"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseInt64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Height", err)
			} else {
				m.Height = int64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Height = int64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Height")
		}
	}

	if rawValue, ok := raw["time"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseInt64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Time", err)
			} else {
				m.Time = int64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Time = int64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Time")
		}
	}

	if rawValue, ok := raw["app_hash"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.AppHash", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.AppHash", err)
		} else {
			m.AppHash = decoded
		}
	}

	if rawValue, ok := raw["proposer_address"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.ProposerAddress", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.ProposerAddress", err)
		} else {
			m.ProposerAddress = decoded
		}
	}


	return nil
}

type TxResult struct {
Code uint32 `cramberry:"1" json:"code"`
Data []byte `cramberry:"2" json:"data"`
Log string `cramberry:"3" json:"log"`
GasUsed uint64 `cramberry:"4" json:"gas_used"`
Events []Event `cramberry:"5" json:"events"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TxResult) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *TxResult) EncodeTo(w *cramberry.Writer) {
	if m.Code != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Varint)
		w.WriteUint32(m.Code)
	}
	if len(m.Data) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Data)
	}
	if m.Log != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Log)
	}
	if m.GasUsed != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.GasUsed)
	}
	if len(m.Events) > 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Events)))
		for _, v := range m.Events {
			v.EncodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TxResult) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *TxResult) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Code = r.ReadUint32()
		case 2:
			m.Data = r.ReadBytes()
		case 3:
			m.Log = r.ReadString()
		case 4:
			m.GasUsed = r.ReadUint64()
		case 5:
			n := r.ReadArrayHeader()
		if r.Err() != nil {
			return
		}
		m.Events = make([]Event, n)
		for i := 0; i < n; i++ {
			m.Events[i].DecodeFrom(r)
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *TxResult) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"code":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatUint64ToString(uint64(m.Code)))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"data":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.Data))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"log":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Log))

	buf.WriteString(",")
	buf.WriteString(`"gas_used":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatUint64ToString(uint64(m.GasUsed)))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"events":`)
	buf.WriteString("[")
	for i, v := range m.Events {
		if i > 0 {
			buf.WriteString(",")
		}
		if msgJSON, err := v.ToJSON(); err != nil {
				return "", err
		} else {
				buf.WriteString(msgJSON)
		}
	}
	buf.WriteString("]")

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *TxResult) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"code": true,
		"data": true,
		"log": true,
		"gas_used": true,
		"events": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["code"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseUint64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Code", err)
			} else {
				m.Code = uint32(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Code = uint32(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Code")
		}
	}

	if rawValue, ok := raw["data"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Data", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.Data", err)
		} else {
			m.Data = decoded
		}
	}

	if rawValue, ok := raw["log"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Log", err)
		}
		m.Log = strVal
	}

	if rawValue, ok := raw["gas_used"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseUint64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.GasUsed", err)
			} else {
				m.GasUsed = uint64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.GasUsed = uint64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.GasUsed")
		}
	}

	if rawValue, ok := raw["events"]; ok {
		var arrRaw []json.RawMessage
		if err := json.Unmarshal(rawValue, &arrRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.Events", err)
		}
		m.Events = make([]Event, len(arrRaw))
		for i, elemRaw := range arrRaw {
			rawValue = elemRaw
				var msg Event
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.Events[i]", err)
				}
				m.Events[i] = msg
		}
	}


	return nil
}

type Event struct {
EventType string `cramberry:"1" json:"event_type"`
Attributes []EventAttribute `cramberry:"2" json:"attributes"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Event) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Event) EncodeTo(w *cramberry.Writer) {
	if m.EventType != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.EventType)
	}
	if len(m.Attributes) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Attributes)))
		for _, v := range m.Attributes {
			v.EncodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Event) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Event) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.EventType = r.ReadString()
		case 2:
			n := r.ReadArrayHeader()
		if r.Err() != nil {
			return
		}
		m.Attributes = make([]EventAttribute, n)
		for i := 0; i < n; i++ {
			m.Attributes[i].DecodeFrom(r)
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *Event) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"event_type":`)
	buf.WriteString(cramberry.EscapeJSONString(m.EventType))

	buf.WriteString(",")
	buf.WriteString(`"attributes":`)
	buf.WriteString("[")
	for i, v := range m.Attributes {
		if i > 0 {
			buf.WriteString(",")
		}
		if msgJSON, err := v.ToJSON(); err != nil {
				return "", err
		} else {
				buf.WriteString(msgJSON)
		}
	}
	buf.WriteString("]")

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *Event) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"event_type": true,
		"attributes": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["event_type"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.EventType", err)
		}
		m.EventType = strVal
	}

	if rawValue, ok := raw["attributes"]; ok {
		var arrRaw []json.RawMessage
		if err := json.Unmarshal(rawValue, &arrRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.Attributes", err)
		}
		m.Attributes = make([]EventAttribute, len(arrRaw))
		for i, elemRaw := range arrRaw {
			rawValue = elemRaw
				var msg EventAttribute
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.Attributes[i]", err)
				}
				m.Attributes[i] = msg
		}
	}


	return nil
}

type EventAttribute struct {
Key string `cramberry:"1" json:"key"`
Value string `cramberry:"2" json:"value"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EventAttribute) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *EventAttribute) EncodeTo(w *cramberry.Writer) {
	if m.Key != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Key)
	}
	if m.Value != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Value)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EventAttribute) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *EventAttribute) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Key = r.ReadString()
		case 2:
			m.Value = r.ReadString()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *EventAttribute) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"key":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Key))

	buf.WriteString(",")
	buf.WriteString(`"value":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Value))

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *EventAttribute) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"key": true,
		"value": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["key"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Key", err)
		}
		m.Key = strVal
	}

	if rawValue, ok := raw["value"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Value", err)
		}
		m.Value = strVal
	}


	return nil
}

type QueryResult struct {
Code uint32 `cramberry:"1" json:"code"`
Data []byte `cramberry:"2" json:"data"`
Log string `cramberry:"3" json:"log"`
Height int64 `cramberry:"4" json:"height"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *QueryResult) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *QueryResult) EncodeTo(w *cramberry.Writer) {
	if m.Code != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Varint)
		w.WriteUint32(m.Code)
	}
	if len(m.Data) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Data)
	}
	if m.Log != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Log)
	}
	if m.Height != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *QueryResult) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *QueryResult) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Code = r.ReadUint32()
		case 2:
			m.Data = r.ReadBytes()
		case 3:
			m.Log = r.ReadString()
		case 4:
			m.Height = r.ReadInt64()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *QueryResult) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"code":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatUint64ToString(uint64(m.Code)))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"data":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.Data))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"log":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Log))

	buf.WriteString(",")
	buf.WriteString(`"height":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatInt64ToString(int64(m.Height)))
	buf.WriteString(`"`)

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *QueryResult) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"code": true,
		"data": true,
		"log": true,
		"height": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["code"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseUint64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Code", err)
			} else {
				m.Code = uint32(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Code = uint32(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Code")
		}
	}

	if rawValue, ok := raw["data"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Data", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.Data", err)
		} else {
			m.Data = decoded
		}
	}

	if rawValue, ok := raw["log"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Log", err)
		}
		m.Log = strVal
	}

	if rawValue, ok := raw["height"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseInt64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Height", err)
			} else {
				m.Height = int64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Height = int64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Height")
		}
	}


	return nil
}

type CommitResult struct {
AppHash []byte `cramberry:"1" json:"app_hash"`
Height int64 `cramberry:"2" json:"height"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *CommitResult) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *CommitResult) EncodeTo(w *cramberry.Writer) {
	if len(m.AppHash) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.AppHash)
	}
	if m.Height != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *CommitResult) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *CommitResult) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.AppHash = r.ReadBytes()
		case 2:
			m.Height = r.ReadInt64()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *CommitResult) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"app_hash":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.AppHash))
	buf.WriteString(`"`)

	buf.WriteString(",")
	buf.WriteString(`"height":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.FormatInt64ToString(int64(m.Height)))
	buf.WriteString(`"`)

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *CommitResult) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"app_hash": true,
		"height": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["app_hash"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.AppHash", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.AppHash", err)
		} else {
			m.AppHash = decoded
		}
	}

	if rawValue, ok := raw["height"]; ok {
		var strVal string
		var numVal float64
		if err := json.Unmarshal(rawValue, &strVal); err == nil {
			if v, err := cramberry.ParseInt64FromString(strVal); err != nil {
				return fmt.Errorf("field %s: %w", "m.Height", err)
			} else {
				m.Height = int64(v)
			}
		} else if err := json.Unmarshal(rawValue, &numVal); err == nil {
			m.Height = int64(numVal)
		} else {
			return fmt.Errorf("field %s: expected string or number", "m.Height")
		}
	}


	return nil
}

type EndBlockResult struct {
ValidatorUpdates []ValidatorUpdate `cramberry:"1" json:"validator_updates"`
Events []Event `cramberry:"2" json:"events"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EndBlockResult) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *EndBlockResult) EncodeTo(w *cramberry.Writer) {
	if len(m.ValidatorUpdates) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.ValidatorUpdates)))
		for _, v := range m.ValidatorUpdates {
			v.EncodeTo(w)
		}
	}
	if len(m.Events) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Events)))
		for _, v := range m.Events {
			v.EncodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EndBlockResult) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *EndBlockResult) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := r.ReadArrayHeader()
		if r.Err() != nil {
			return
		}
		m.ValidatorUpdates = make([]ValidatorUpdate, n)
		for i := 0; i < n; i++ {
			m.ValidatorUpdates[i].DecodeFrom(r)
		}
		case 2:
			n := r.ReadArrayHeader()
		if r.Err() != nil {
			return
		}
		m.Events = make([]Event, n)
		for i := 0; i < n; i++ {
			m.Events[i].DecodeFrom(r)
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *EndBlockResult) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"validator_updates":`)
	buf.WriteString("[")
	for i, v := range m.ValidatorUpdates {
		if i > 0 {
			buf.WriteString(",")
		}
		if msgJSON, err := v.ToJSON(); err != nil {
				return "", err
		} else {
				buf.WriteString(msgJSON)
		}
	}
	buf.WriteString("]")

	buf.WriteString(",")
	buf.WriteString(`"events":`)
	buf.WriteString("[")
	for i, v := range m.Events {
		if i > 0 {
			buf.WriteString(",")
		}
		if msgJSON, err := v.ToJSON(); err != nil {
				return "", err
		} else {
				buf.WriteString(msgJSON)
		}
	}
	buf.WriteString("]")

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *EndBlockResult) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"validator_updates": true,
		"events": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["validator_updates"]; ok {
		var arrRaw []json.RawMessage
		if err := json.Unmarshal(rawValue, &arrRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.ValidatorUpdates", err)
		}
		m.ValidatorUpdates = make([]ValidatorUpdate, len(arrRaw))
		for i, elemRaw := range arrRaw {
			rawValue = elemRaw
				var msg ValidatorUpdate
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.ValidatorUpdates[i]", err)
				}
				m.ValidatorUpdates[i] = msg
		}
	}

	if rawValue, ok := raw["events"]; ok {
		var arrRaw []json.RawMessage
		if err := json.Unmarshal(rawValue, &arrRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.Events", err)
		}
		m.Events = make([]Event, len(arrRaw))
		for i, elemRaw := range arrRaw {
			rawValue = elemRaw
				var msg Event
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.Events[i]", err)
				}
				m.Events[i] = msg
		}
	}


	return nil
}

type SignDocCoin struct {
Denom string `cramberry:"1" json:"denom"`
Amount string `cramberry:"2" json:"amount"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDocCoin) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *SignDocCoin) EncodeTo(w *cramberry.Writer) {
	if m.Denom != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Denom)
	}
	if m.Amount != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Amount)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDocCoin) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *SignDocCoin) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Denom = r.ReadString()
		case 2:
			m.Amount = r.ReadString()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *SignDocCoin) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"denom":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Denom))

	buf.WriteString(",")
	buf.WriteString(`"amount":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Amount))

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *SignDocCoin) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"denom": true,
		"amount": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["denom"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Denom", err)
		}
		m.Denom = strVal
	}

	if rawValue, ok := raw["amount"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Amount", err)
		}
		m.Amount = strVal
	}


	return nil
}

type SignDocFee struct {
Amount []SignDocCoin `cramberry:"1" json:"amount"`
GasLimit string `cramberry:"2" json:"gas_limit"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDocFee) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *SignDocFee) EncodeTo(w *cramberry.Writer) {
	if len(m.Amount) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Amount)))
		for _, v := range m.Amount {
			v.EncodeTo(w)
		}
	}
	if m.GasLimit != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.GasLimit)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDocFee) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *SignDocFee) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := r.ReadArrayHeader()
		if r.Err() != nil {
			return
		}
		m.Amount = make([]SignDocCoin, n)
		for i := 0; i < n; i++ {
			m.Amount[i].DecodeFrom(r)
		}
		case 2:
			m.GasLimit = r.ReadString()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *SignDocFee) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"amount":`)
	buf.WriteString("[")
	for i, v := range m.Amount {
		if i > 0 {
			buf.WriteString(",")
		}
		if msgJSON, err := v.ToJSON(); err != nil {
				return "", err
		} else {
				buf.WriteString(msgJSON)
		}
	}
	buf.WriteString("]")

	buf.WriteString(",")
	buf.WriteString(`"gas_limit":`)
	buf.WriteString(cramberry.EscapeJSONString(m.GasLimit))

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *SignDocFee) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"amount": true,
		"gas_limit": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["amount"]; ok {
		var arrRaw []json.RawMessage
		if err := json.Unmarshal(rawValue, &arrRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.Amount", err)
		}
		m.Amount = make([]SignDocCoin, len(arrRaw))
		for i, elemRaw := range arrRaw {
			rawValue = elemRaw
				var msg SignDocCoin
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.Amount[i]", err)
				}
				m.Amount[i] = msg
		}
	}

	if rawValue, ok := raw["gas_limit"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.GasLimit", err)
		}
		m.GasLimit = strVal
	}


	return nil
}

type SignDocRatio struct {
Numerator string `cramberry:"1" json:"numerator"`
Denominator string `cramberry:"2" json:"denominator"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDocRatio) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *SignDocRatio) EncodeTo(w *cramberry.Writer) {
	if m.Numerator != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Numerator)
	}
	if m.Denominator != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Denominator)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDocRatio) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *SignDocRatio) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Numerator = r.ReadString()
		case 2:
			m.Denominator = r.ReadString()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *SignDocRatio) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"numerator":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Numerator))

	buf.WriteString(",")
	buf.WriteString(`"denominator":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Denominator))

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *SignDocRatio) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"numerator": true,
		"denominator": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["numerator"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Numerator", err)
		}
		m.Numerator = strVal
	}

	if rawValue, ok := raw["denominator"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Denominator", err)
		}
		m.Denominator = strVal
	}


	return nil
}

type SignDocMessage struct {
MsgType string `cramberry:"1" json:"msg_type"`
Data []byte `cramberry:"2" json:"data"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDocMessage) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *SignDocMessage) EncodeTo(w *cramberry.Writer) {
	if m.MsgType != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.MsgType)
	}
	if len(m.Data) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Data)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDocMessage) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *SignDocMessage) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.MsgType = r.ReadString()
		case 2:
			m.Data = r.ReadBytes()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *SignDocMessage) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"msg_type":`)
	buf.WriteString(cramberry.EscapeJSONString(m.MsgType))

	buf.WriteString(",")
	buf.WriteString(`"data":`)
	buf.WriteString(`"`)
	buf.WriteString(cramberry.EncodeBase64(m.Data))
	buf.WriteString(`"`)

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *SignDocMessage) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"msg_type": true,
		"data": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["msg_type"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.MsgType", err)
		}
		m.MsgType = strVal
	}

	if rawValue, ok := raw["data"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Data", err)
		}
		if decoded, err := cramberry.DecodeBase64(strVal); err != nil {
			return fmt.Errorf("field %s: invalid base64: %w", "m.Data", err)
		} else {
			m.Data = decoded
		}
	}


	return nil
}

type SignDoc struct {
Version string `cramberry:"1" json:"version"`
ChainId string `cramberry:"2" json:"chain_id"`
Account string `cramberry:"3" json:"account"`
AccountSequence string `cramberry:"4" json:"account_sequence"`
Messages []SignDocMessage `cramberry:"5" json:"messages"`
Nonce string `cramberry:"6" json:"nonce"`
Memo string `cramberry:"7" json:"memo"`
Fee SignDocFee `cramberry:"8" json:"fee"`
FeeSlippage SignDocRatio `cramberry:"9" json:"fee_slippage"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDoc) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *SignDoc) EncodeTo(w *cramberry.Writer) {
	if m.Version != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Version)
	}
	if m.ChainId != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.ChainId)
	}
	if m.Account != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Account)
	}
	if m.AccountSequence != "" {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(m.AccountSequence)
	}
	if len(m.Messages) > 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Messages)))
		for _, v := range m.Messages {
			v.EncodeTo(w)
		}
	}
	if m.Nonce != "" {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Nonce)
	}
	if m.Memo != "" {
		w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Memo)
	}
	w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
	m.Fee.EncodeTo(w)
	w.WriteCompactTag(9, cramberry.WireTypeV2Bytes)
	m.FeeSlippage.EncodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignDoc) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *SignDoc) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Version = r.ReadString()
		case 2:
			m.ChainId = r.ReadString()
		case 3:
			m.Account = r.ReadString()
		case 4:
			m.AccountSequence = r.ReadString()
		case 5:
			n := r.ReadArrayHeader()
		if r.Err() != nil {
			return
		}
		m.Messages = make([]SignDocMessage, n)
		for i := 0; i < n; i++ {
			m.Messages[i].DecodeFrom(r)
		}
		case 6:
			m.Nonce = r.ReadString()
		case 7:
			m.Memo = r.ReadString()
		case 8:
			m.Fee.DecodeFrom(r)
		case 9:
			m.FeeSlippage.DecodeFrom(r)
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ToJSON encodes the message to deterministic JSON format.
// All integers are encoded as strings to prevent precision loss in JavaScript.
// Output is compact (no whitespace) with lexicographically sorted map keys.
func (m *SignDoc) ToJSON() (string, error) {

	var buf strings.Builder
	buf.WriteString("{")
	buf.WriteString(`"version":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Version))

	buf.WriteString(",")
	buf.WriteString(`"chain_id":`)
	buf.WriteString(cramberry.EscapeJSONString(m.ChainId))

	buf.WriteString(",")
	buf.WriteString(`"account":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Account))

	buf.WriteString(",")
	buf.WriteString(`"account_sequence":`)
	buf.WriteString(cramberry.EscapeJSONString(m.AccountSequence))

	buf.WriteString(",")
	buf.WriteString(`"messages":`)
	buf.WriteString("[")
	for i, v := range m.Messages {
		if i > 0 {
			buf.WriteString(",")
		}
		if msgJSON, err := v.ToJSON(); err != nil {
				return "", err
		} else {
				buf.WriteString(msgJSON)
		}
	}
	buf.WriteString("]")

	buf.WriteString(",")
	buf.WriteString(`"nonce":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Nonce))

	buf.WriteString(",")
	buf.WriteString(`"memo":`)
	buf.WriteString(cramberry.EscapeJSONString(m.Memo))

	buf.WriteString(",")
	buf.WriteString(`"fee":`)
	if msgJSON, err := m.Fee.ToJSON(); err != nil {
		return "", err
	} else {
		buf.WriteString(msgJSON)
	}

	buf.WriteString(",")
	buf.WriteString(`"fee_slippage":`)
	if msgJSON, err := m.FeeSlippage.ToJSON(); err != nil {
		return "", err
	} else {
		buf.WriteString(msgJSON)
	}

	buf.WriteString("}")
	return buf.String(), nil
}

// FromJSON decodes the message from JSON format.
// Accepts both string-encoded and numeric integers for flexibility.
// Unknown fields cause an error (strict mode).
func (m *SignDoc) FromJSON(s string) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal([]byte(s), &raw); err != nil {
		return fmt.Errorf("FromJSON: %w", err)
	}

	// Check for unknown fields (strict mode)
	allowedFields := map[string]bool{
		"version": true,
		"chain_id": true,
		"account": true,
		"account_sequence": true,
		"messages": true,
		"nonce": true,
		"memo": true,
		"fee": true,
		"fee_slippage": true,
	}
	for key := range raw {
		if !allowedFields[key] {
			return fmt.Errorf("FromJSON: unknown field %q", key)
		}
	}

	// Decode fields
	if rawValue, ok := raw["version"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Version", err)
		}
		m.Version = strVal
	}

	if rawValue, ok := raw["chain_id"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.ChainId", err)
		}
		m.ChainId = strVal
	}

	if rawValue, ok := raw["account"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Account", err)
		}
		m.Account = strVal
	}

	if rawValue, ok := raw["account_sequence"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.AccountSequence", err)
		}
		m.AccountSequence = strVal
	}

	if rawValue, ok := raw["messages"]; ok {
		var arrRaw []json.RawMessage
		if err := json.Unmarshal(rawValue, &arrRaw); err != nil {
			return fmt.Errorf("field %s: %w", "m.Messages", err)
		}
		m.Messages = make([]SignDocMessage, len(arrRaw))
		for i, elemRaw := range arrRaw {
			rawValue = elemRaw
				var msg SignDocMessage
				if err := msg.FromJSON(string(rawValue)); err != nil {
						return fmt.Errorf("field %s: %w", "m.Messages[i]", err)
				}
				m.Messages[i] = msg
		}
	}

	if rawValue, ok := raw["nonce"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Nonce", err)
		}
		m.Nonce = strVal
	}

	if rawValue, ok := raw["memo"]; ok {
		var strVal string
		if err := json.Unmarshal(rawValue, &strVal); err != nil {
			return fmt.Errorf("field %s: %w", "m.Memo", err)
		}
		m.Memo = strVal
	}

	if rawValue, ok := raw["fee"]; ok {
		var msg SignDocFee
		if err := msg.FromJSON(string(rawValue)); err != nil {
			return fmt.Errorf("field %s: %w", "m.Fee", err)
		}
		m.Fee = msg
	}

	if rawValue, ok := raw["fee_slippage"]; ok {
		var msg SignDocRatio
		if err := msg.FromJSON(string(rawValue)); err != nil {
			return fmt.Errorf("field %s: %w", "m.FeeSlippage", err)
		}
		m.FeeSlippage = msg
	}


	return nil
}


